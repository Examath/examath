<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>gbXML Transformer</title>
    <link id="asostyle" rel="stylesheet" type="text/css" href="https://examath.github.io/examath/ASO.css">
</head>
<body>
    <h2>Revit 2025 gbXML export fixer</h2>
    <p>This tool corrects the ids of gbXML exports from Revit 2025. The tool will: </p>
    <ul> 
        <li>Replaces autogenerated IDs (<code>aim1234</code>) with the value of their direct <code>&lt;Name&gt;</code> child</li>
        <li>Ensures all <code>&lt;Name&gt;</code> values are unique</li>
        <li>Updates all reference attributes ending in <code>Ref</code></li> 
    </ul>
    <p><b>Disclaimer: </b>This tool is almost entirley generated using LLM (GPT-5.1). The code has been audited for functionality but not for form. Created: 19/01/2026.</p>

    <div class="toolbar">
        <input type="file" id="fileInput" accept=".xml">
        <input type="button" id="processBtn" onclick="process()" value="Process" />
    </div>

    <h3>Status</h3>
<pre id="status">Waiting…</pre>

    <script>
async function process() {
    const fileInput = document.getElementById("fileInput");
    const status = document.getElementById("status");

    status.textContent = "";

    if (!fileInput.files.length) {
        status.textContent = "Please select an XML file first.";
        return;
    }

    const file = fileInput.files[0];
    const text = await file.text();

    try {
        const parser = new DOMParser();
        const xml = parser.parseFromString(text, "application/xml");

        // Check for parse errors
        if (xml.querySelector("parsererror")) {
            status.textContent += "\nXML parsing error see console.";
            console.error("xml error", xml.querySelector("parsererror"));
            return;
        }

        // STEP 1 — Build map of oldId → newId
        const idMap = {};
        const items = xml.querySelectorAll("[id]");

        items.forEach(el => {
            const oldId = el.getAttribute("id");
            const nameEl = el.querySelector(":scope > Name");

            if (oldId.startsWith("aim") && nameEl) {
                const newId = nameEl.textContent.trim();

                if (idMap[oldId]) {
                    throw new Error(`Duplicate id attribute '${oldId}'`);
                }

                idMap[oldId] = newId;
            }
        });

        status.textContent += `\n${Object.keys(idMap).length} aim**** ids found.`;
        console.table(idMap);

        // STEP 2 — Ensure Name values are unique
        const nameValues = Object.values(idMap);
        const duplicates = nameValues.filter((v, i) => nameValues.indexOf(v) !== i);

        if (duplicates.length > 0) {
            throw new Error("Duplicate <Name> values:\n  " + duplicates.join("\n  "));
        }

        status.textContent += "\nNo unique names found, which is good.";

        // STEP 3 — Replace id attributes

        items.forEach(el => {
            const oldId = el.getAttribute("id");
            if (idMap[oldId]) {
                el.setAttribute("id", idMap[oldId]);
            }
        });

        // STEP 4 — Update reference attributes (any attr ending with "Ref")
        var repCount = 0;
        xml.querySelectorAll("*").forEach(el => {
            for (const attr of el.attributes) {
                if (attr.name.toLowerCase().endsWith("ref")) {
                    const oldRef = attr.value;
                    if (idMap[oldRef]) {
                        attr.value = idMap[oldRef];
                        repCount++;
                    }
                }
            }
        });

        status.textContent += `\n${repCount} references substituted.`;

        // STEP 5 — Serialize and download
        const serializer = new XMLSerializer();
        const output = serializer.serializeToString(xml);

        const blob = new Blob([output], { type: "application/xml" });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = "output.xml";
        a.click();

        URL.revokeObjectURL(url);

        status.textContent += "\nSuccess — output.xml now downloadable.";

    } catch (err) {
        status.textContent += "\nError: " + err.message;
    }
};
    </script>

</body>
</html>
