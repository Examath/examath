<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>gbXML Transformer</title>
    <link id="asostyle" rel="stylesheet" type="text/css" href="https://examath.github.io/examath/ASO.css">
</head>
<body>
    <h2>Revit 2025 gbXML export fixer</h2>
    <p>This tool corrects the ids of gbXML exports from Revit 2025. The tool will: </p>
    <ul> 
        <li>Replaces autogenerated IDs (<code>aim1234</code>) with the value of their direct <code>&lt;Name&gt;</code> child</li>
        <li>Ensures all <code>&lt;Name&gt;</code> values are unique</li>
        <li>Updates all reference attributes ending in <code>Ref</code></li> 
    </ul>
    <p><b>Disclaimer: </b>This tool was partly generated using LLM (GPT-5.1). The code has been audited for functionality but not for form. Created: 19/01/2026 - 20/01/2026. Paul Cyril.</p>

    <div class="toolbar">
        <input type="file" id="fileInput" accept=".xml">
        <input type="button" id="processBtn" onclick="process()" value="Process" />
    </div>

    <h3>Status</h3>
<pre id="status">Waiting…</pre>

    <script>
async function process() {
    const fileInput = document.getElementById("fileInput");
    const status = document.getElementById("status");

    status.textContent = "";

    if (!fileInput.files.length) {
        status.textContent = "Please select an XML file first.";
        return;
    }

    const file = fileInput.files[0];
    const text = await file.text();

    try {
        const parser = new DOMParser();
        const xml = parser.parseFromString(text, "application/xml");

        // Check for parse errors
        if (xml.querySelector("parsererror")) {
            status.textContent += "\nXML parsing error see console.";
            console.error("xml error", xml.querySelector("parsererror"));
            return;
        }

        // STEP 1 — Build map of oldId → newId
        const idMap = new Map();
        const newIds = new Set();
        var dupNewIds = 0;
        const items = xml.querySelectorAll("[id]");
        
        status.textContent += `\n${items.length} elements with ids found.`;

        items.forEach(el => {
            const oldId = el.getAttribute("id");
            const nameEl = el.querySelector(":scope > Name");

            if (oldId.startsWith("aim") && nameEl) {
                var newId = nameEl.textContent.trim();

                if (idMap.has(oldId)) {
                    throw new Error(`Duplicate id attribute '${oldId}'`);
                }

                if (newIds.has(newId)) {
                    dupNewIds++;
                    newId = `${nameEl.textContent.trim()} <${el.tagName}>`;
                }

                if (newIds.has(newId)) {
                    newId = `${nameEl.textContent.trim()} [${oldId}]`;
                }

                idMap.set(oldId, newId);
                newIds.add(newId);
            }
        });

        status.textContent += `\n${idMap.size} aim**** ids found, where names are more suitable.`;
        status.textContent += `\n${dupNewIds} duplicate names found.`;
        console.table(Array.from(idMap, ([key, value]) => ({ Key: key, Value: value })));

        // STEP 2 — Replace id attributes

        items.forEach(el => {
            const oldId = el.getAttribute("id");
            if (idMap.has(oldId)) {
                el.setAttribute("id", idMap.get(oldId));
            }
        });

        // STEP 3 — Update reference attributes (any attr ending with "Ref")
        var repCount = 0;
        xml.querySelectorAll("*").forEach(el => {
            for (const attr of el.attributes) {
                if (attr.name.toLowerCase().endsWith("ref")) {
                    const oldId = attr.value;
                    if (idMap.has(oldId)) {
                        attr.value = idMap.get(oldId);
                        repCount++;
                    }
                }
            }
        });

        status.textContent += `\n${repCount} references substituted.`;

        // STEP 5 — Serialize and download
        const serializer = new XMLSerializer();
        const output = serializer.serializeToString(xml);

        const blob = new Blob([output], { type: "application/xml" });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = "output.xml";
        a.click();

        URL.revokeObjectURL(url);

        status.textContent += "\nSuccess — output.xml now downloadable.";

    } catch (err) {
        status.textContent += "\nError: " + err.message;
        throw err;
    }
};
    </script>

</body>
</html>
